==============================================================================
互联网公司常见的面试算法题
https://www.zhihu.com/question/24964987

==============================================================================

二叉树两个节点之间距离?
假设给定的节点为node1,node2,可以分为下面的两种情况：
1）node1是node2的祖先节点或孩子结点，可以理解为两个节点在一条线上。例如：Dist(2,4),Dist(6,1)
2）node1和node2没有直接或间接的父子关系。例如，Dist(4,3)，他们需要一个共同的祖先结点1连接起来
假设lca是两个节点的最低公共祖先节点：
Dist(n1,n2)=Dist(root,n1)+Dist(root,n2)-2*Dist(root,lca)
这个公式已经涵盖了上面的两种情况。先找出lca,再求root节点到某个节点的距离就比较简单了。

计算一个二叉树的最大距离有两个情况：
情况1: 路径经过左子树的最深节点，通过根节点，再到右子树的最深节点。
情况2: 路径不穿过根节点，而是左子树或右子树的最大距离路径，取其大者。
只需要计算这两个情况的路径距离，并取其大者，就是该二叉树的最大距离。

==============================================================================

realloc(void *__ptr, size_t __size)：更改已经配置的内存空间，即更改由malloc()函数分配的内存空间的大小。
如果将分配的内存减少，realloc仅仅是改变索引的信息。
如果是将分配的内存扩大，则有以下情况：
1）如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回原指针。
2）如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存块位置。
3）如果申请失败，将返回NULL，此时，原来的指针仍然有效。

注意：如果调用成功，不管当前内存段后面的空闲空间是否满足要求，都会释放掉原来的指针，重新返回一个指针，虽然返回的指针有可能和原来的指针一样，即不能再次释放掉原来的指针。

==============================================================================

SPF算法描述：
算法思想：设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。

算法步骤：

a.初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则<u,v>正常有权值，若u不是v的出边邻接点，则<u,v>权值为∞。

b.从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。

c.以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。

d.重复步骤b和c直到所有顶点都包含在S中。

==============================================================================

struct的首地址即为第一个元素的首地址
给定结构体中的某个元素的地址，可以计算出这个结构体的起始地址：
#define STRUCT_OFFSET(id, element) ((unsigned long) &((struct id*)0)->element)
通过宏STRUCT_OFFSET来计算结构体元素与结构体首地址之间的偏移，然后用结构体元素的地址减去偏移就可以获得结构体的地址

==============================================================================

sizeof是一个宏，不是函数，strlen是一个函数，sizeof的实现利用的是指针步长的特性
针对类型的sizeof #define _sizeof(T) (size_t)((T*)0 + 1)
针对变量名的sizeof #define array_sizeof(T) ((size_t)(&T + 1)) - ((size_t)(&T))
printf("int length = %lu\n", _sizeof(int));
printf("int a length = %lu\n", array_sizeof(a));
printf("int[10] length = %lu\n", array_sizeof(b));

==============================================================================

柔性数组即数组大小待定的数组，C语言中结构体的最后一个元素可以是大小未知的数组，也就是所谓的0长度，所以我们可以用结构体来创建柔性数组。
它的主要用途是为了满足需要变长度的结构体，为了解决使用数组时内存的冗余和数组的越界问题。
在一个结构体的最后 ，申明一个长度为空的数组，就可以使得这个结构体是可变长的。对于编译器来说，此时长度为0的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量， 数组名这个符号本身代 表了一个不可修改的地址常量 （注意：数组名永远都不会是指针！ ），但对于这个数组的大小，我们可以进行动态分配,对于编译器而言，数组名仅仅是一个符号，它不会占用任何空间，它在结构体中，只是代表了一个偏移量，代表一个不可修改的地址常量！
typedef struct _SoftArray{
int len;
int array[];
}SoftArray;
int main()
{
    int len=10,i=0;
    
    SoftArray *p=(SoftArray*)malloc(sizeof(SoftArray)+sizeof(int)*len);
    p->len=len;
    
    for(i=0;i<p->len;i++)
   {
        p->array[i]=i+1;
    }
    for(i=0;i<p->len;i++)
   {  
        printf("%d\n",p->array[i]);
    }

    free(p);

    return 0;
}
结构体中使用柔性数组，可以一次性将所需的内存空间申请出来(所以内存是连续的，内存碎片也减少了)，因为如果是以指针形式声明的，那么就必须做两次内存申请(结构体一次，成员s一次)

==============================================================================
结构体对齐原则：
原则一：结构体中元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每一个元素放置到内存中时，它都会认为内存是以它自己的大小来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始（以结构体变量首地址为0计算）。

原则二：在经过第一原则分析后，检查计算出的存储单元是否为所有元素中最宽的元素的长度的整数倍，是，则结束；若不是，则补齐为它的整数倍。

==============================================================================
32位操作系统
char ：1个字节(固定)
*(即指针变量): 4个字节(32位机的寻址空间是4个字节。同理64位编译器)(变化*)
short int : 2个字节(固定)
int： 4个字节(固定)
unsigned int : 4个字节(固定)
float: 4个字节(固定)
double: 8个字节(固定)
long: 4个字节
unsigned long: 4个字节(变化*,其实就是寻址控件的地址长度数值)
long long: 8个字节(固定)

64位操作系统
char ：1个字节(固定)
*(即指针变量): 8个字节
short int : 2个字节(固定)
int： 4个字节(固定)
unsigned int : 4个字节(固定)
float: 4个字节(固定)
double: 8个字节(固定)
long: 8个字节
unsigned long: 8个字节(变化*其实就是寻址控件的地址长度数值)
long long: 8个字节(固定)

==============================================================================

判断链表中是否有环：
设定两个指针，一个慢指针，一个快指针，快指针的速度是慢指针的两倍，然后呢，如果有环，他们一定会在环中相遇。 
用一个指针，从相遇点出发，当其再次回到相遇点时，其走过的长度就是环的长度
然后一个指针从链表的起始点，一个指针从链表中环的相遇点，当两个指针再次相遇时，相遇点就是环的入口点

==============================================================================

找到链表中第K个节点
p1和p2分别都是head指针，先将p2向右移动k次。
继续保持p1和p2等间距的右移，当p2的next为null，则证明p1所指的结点的值为倒数第k个节点的值

==============================================================================

找到链表的中间节点
定义两个指针，都指向链表的第一个成员，然后快的指针每次走两步，慢的指针每次走一步，当快指针指向的next为NULL即链表结点为奇数个的时候，或者，快指针快指针自身为空的时候停下，即链表元素为偶数个，此时的慢指针走了s步,则快指针走了2s步，则此时 慢指针所指向的结点为中间节点；

==============================================================================

extern有两个作用：
第一个,当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的"脾气"了(不同的编译器采用的方法不一样)，为什么这么做呢，因为C++支持函数的重载啊，在这里不去过多的论述这个问题，如果你有兴趣可以去网上搜索，相信你可以得到满意的解释!
第二，当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。

在一个源文件里定义了一个数组：char a[6];
　　在另外一个文件里用下列语句进行了声明：extern char *a；
　　请问，这样可以吗？ 
　　答案与分析：
　　1)、不可以，程序运行时会告诉你非法访问。原因在于，指向类型T的指针并不等价于类型T的数组。extern char *a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]。
　　2)、例子分析如下，如果a[] = "abcd",则外部变量a=0x61626364 (abcd的ASCII码值)，*a显然没有意义
　　显然a指向的空间（0x61626364）没有意义，易出现非法内存访问。
　　3)、这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。
　　4)、extern用在变量声明中常常有这样一个作用，你在*.c文件中声明了一个全局的变量，这个全局的变量如果要被引用，就放在*.h中并用extern来声明。

//在.h文件的头上
#ifdef __cplusplus
#if __cplusplus
extern "C"{
　#endif
　#endif /* __cplusplus */ 
　…
　…
　//.h文件结束的地方
　#ifdef __cplusplus
　#if __cplusplus
}
#endif
#endif /* __cplusplus */ 

如果函数的声明中带有关键字extern，仅仅是暗示这个函数可能在别的源文件里定义，没有其它作用。即下述两个函数声明没有明显的区别：
extern int f(); 和int f();
当然，这样的用处还是有的，就是在程序中取代include “*.h”来声明函数

==============================================================================
在C语言中static的作用如下

第一、在修饰变量的时候，static修饰的静态局部变量只执行一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。 
第二、static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。 
第三、static修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。Static修饰的局部变量存放在全局数据区的静态变量区。初始化的时候自动初始化为0； 
（1）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用static修饰 
（2）考虑到数据安全性（当程想要使用全局变量的时候应该先考虑使用static）
==============================================================================

在 1G 内存的计算机中能否 malloc(1.2G) ？为什么？

malloc能够申请的空间大小与物理内存的大小没有直接关系，仅与程序的虚拟地址空间相关。程序运行时，堆空间只是程序向操作系统申请划出来的一大块虚拟地址空间。应用程序通过malloc申请空间，得到的是在虚拟地址空间中的地址，之后程序运行所提供的物理内存是由操作系统完成的。
本题要申请空间的大小为 1.2G=2 30 × 1.2 Byte ，转换为十六进制约为 4CCC CCCC ，这个数值已经超过了 int 类型的表示范围，但还在unsigned 的表示范围。幸运的是 malloc 函数要求的参数为 unsigned 。

==============================================================================

0x01020304
小尾端 04 03 02 01
大尾端 01 02 03 04
int x=0x01;
if(*((char*)&x))
    小尾端
else
    大尾端

==============================================================================



==============================================================================
栈
队列
链表
数组
二叉树
动态规划
背包问题
LCS
