==============================================================================
互联网公司常见的面试算法题
https://www.zhihu.com/question/24964987

==============================================================================

二叉树两个节点之间距离?
假设给定的节点为node1,node2,可以分为下面的两种情况：
1）node1是node2的祖先节点或孩子结点，可以理解为两个节点在一条线上。例如：Dist(2,4),Dist(6,1)
2）node1和node2没有直接或间接的父子关系。例如，Dist(4,3)，他们需要一个共同的祖先结点1连接起来
假设lca是两个节点的最低公共祖先节点：
Dist(n1,n2)=Dist(root,n1)+Dist(root,n2)-2*Dist(root,lca)
这个公式已经涵盖了上面的两种情况。先找出lca,再求root节点到某个节点的距离就比较简单了。

计算一个二叉树的最大距离有两个情况：
情况1: 路径经过左子树的最深节点，通过根节点，再到右子树的最深节点。
情况2: 路径不穿过根节点，而是左子树或右子树的最大距离路径，取其大者。
只需要计算这两个情况的路径距离，并取其大者，就是该二叉树的最大距离。

==============================================================================

realloc(void *__ptr, size_t __size)：更改已经配置的内存空间，即更改由malloc()函数分配的内存空间的大小。
如果将分配的内存减少，realloc仅仅是改变索引的信息。
如果是将分配的内存扩大，则有以下情况：
1）如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回原指针。
2）如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存块位置。
3）如果申请失败，将返回NULL，此时，原来的指针仍然有效。

注意：如果调用成功，不管当前内存段后面的空闲空间是否满足要求，都会释放掉原来的指针，重新返回一个指针，虽然返回的指针有可能和原来的指针一样，即不能再次释放掉原来的指针。

==============================================================================

SPF算法描述：
算法思想：设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。

算法步骤：

a.初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则<u,v>正常有权值，若u不是v的出边邻接点，则<u,v>权值为∞。

b.从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。

c.以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。

d.重复步骤b和c直到所有顶点都包含在S中。

==============================================================================

struct的首地址即为第一个元素的首地址
给定结构体中的某个元素的地址，可以计算出这个结构体的起始地址：
#define STRUCT_OFFSET(id, element) ((unsigned long) &((struct id*)0)->element)
通过宏STRUCT_OFFSET来计算结构体元素与结构体首地址之间的偏移，然后用结构体元素的地址减去偏移就可以获得结构体的地址

==============================================================================

sizeof是一个宏，不是函数，strlen是一个函数，sizeof的实现利用的是指针步长的特性
针对类型的sizeof #define _sizeof(T) (size_t)((T*)0 + 1)
针对变量名的sizeof #define array_sizeof(T) ((size_t)(&T + 1)) - ((size_t)(&T))
printf("int length = %lu\n", _sizeof(int));
printf("int a length = %lu\n", array_sizeof(a));
printf("int[10] length = %lu\n", array_sizeof(b));

==============================================================================

柔性数组即数组大小待定的数组，C语言中结构体的最后一个元素可以是大小未知的数组，也就是所谓的0长度，所以我们可以用结构体来创建柔性数组。
它的主要用途是为了满足需要变长度的结构体，为了解决使用数组时内存的冗余和数组的越界问题。
在一个结构体的最后 ，申明一个长度为空的数组，就可以使得这个结构体是可变长的。对于编译器来说，此时长度为0的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量， 数组名这个符号本身代 表了一个不可修改的地址常量 （注意：数组名永远都不会是指针！ ），但对于这个数组的大小，我们可以进行动态分配,对于编译器而言，数组名仅仅是一个符号，它不会占用任何空间，它在结构体中，只是代表了一个偏移量，代表一个不可修改的地址常量！
typedef struct _SoftArray{
int len;
int array[];
}SoftArray;
int main()
{
    int len=10,i=0;
    
    SoftArray *p=(SoftArray*)malloc(sizeof(SoftArray)+sizeof(int)*len);
    p->len=len;
    
    for(i=0;i<p->len;i++)
   {
        p->array[i]=i+1;
    }
    for(i=0;i<p->len;i++)
   {  
        printf("%d\n",p->array[i]);
    }

    free(p);

    return 0;
}
结构体中使用柔性数组，可以一次性将所需的内存空间申请出来(所以内存是连续的，内存碎片也减少了)，因为如果是以指针形式声明的，那么就必须做两次内存申请(结构体一次，成员s一次)

==============================================================================
结构体对齐原则：
原则一：结构体中元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每一个元素放置到内存中时，它都会认为内存是以它自己的大小来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始（以结构体变量首地址为0计算）。

原则二：在经过第一原则分析后，检查计算出的存储单元是否为所有元素中最宽的元素的长度的整数倍，是，则结束；若不是，则补齐为它的整数倍。

==============================================================================

判断链表中是否有环：
设定两个指针，一个慢指针，一个快指针，快指针的速度是慢指针的两倍，然后呢，如果有环，他们一定会在环中相遇。 
用一个指针，从相遇点出发，当其再次回到相遇点时，其走过的长度就是环的长度
然后一个指针从链表的起始点，一个指针从链表中环的相遇点，当两个指针再次相遇时，相遇点就是环的入口点

==============================================================================

找到链表中第K个节点
p1和p2分别都是head指针，先将p2向右移动k次。
继续保持p1和p2等间距的右移，当p2的next为null，则证明p1所指的结点的值为倒数第k个节点的值

==============================================================================

找到链表的中间节点
定义两个指针，都指向链表的第一个成员，然后快的指针每次走两步，慢的指针每次走一步，当快指针指向的next为NULL即链表结点为奇数个的时候，或者，快指针快指针自身为空的时候停下，即链表元素为偶数个，此时的慢指针走了s步,则快指针走了2s步，则此时 慢指针所指向的结点为中间节点；

==============================================================================
栈
队列
链表
数组
二叉树
动态规划
背包问题
LCS
